name: "ðŸ—ï¸ Build Prebuilds"

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

env:
  # PodFirst: Bumped cache versions to force rebuild with indev support
  CACHE_VERSION_WINDOWS: "v18-podfirst"
  CACHE_VERSION_LINUX: "v33-podfirst"
  CACHE_VERSION_MACOS: "v16-podfirst"
  # JELLYFIN_FFMPEG_HASH: "21198ee5630df2b0dabe4bb416e6c9c4a32522ed"

on:
  workflow_dispatch:
    inputs:
      upload_caches:
        description: "Upload FFmpeg caches as artifacts for debugging"
        required: false
        default: false
        type: boolean
  workflow_call:
    secrets:
      NPM_TOKEN:
        required: false
        description: "NPM token for publishing packages"
  push:
    branches:
      - main
    paths:
      - "src/**"
      - "test/**"
      - "externals/jellyfin-ffmpeg/**"
      - ".github/workflows/build-prebuilds.yaml"
      - "binding-jellyfin.gyp"
      - "patches/**"
  pull_request:
    paths:
      - "src/**"
      - "test/**"
      - "externals/jellyfin-ffmpeg/**"
      - ".github/workflows/build-prebuilds.yaml"
      - "binding-jellyfin.gyp"
      - "patches/**"

jobs:
  build_windows_mingw:
    name: "Windows MinGW ${{ matrix.os.arch }}"
    runs-on: ${{ matrix.os.runner }}
    strategy:
      fail-fast: false
      matrix:
        os:
          - name: CLANG64
            arch: x64
            runner: windows-2022
            msystem: CLANG64
            toolchain: mingw-w64-clang-x86_64-toolchain
            nasm: mingw-w64-clang-x86_64-nasm
            build_script: ./msys2/build.sh
          - name: CLANGARM64
            arch: arm64
            runner: windows-11-arm
            msystem: CLANGARM64
            toolchain: mingw-w64-clang-aarch64-toolchain
            nasm: mingw-w64-clang-aarch64-nasm
            build_script: ./msys2/buildarm64.sh
    defaults:
      run:
        shell: msys2 {0}
    steps:
      - uses: msys2/setup-msys2@v2
        with:
          update: true
          msystem: ${{ matrix.os.msystem }}
          install: >-
            git
            curl
            wget
            zip
            ${{ matrix.os.toolchain }}
            quilt
            diffstat
            ${{ matrix.os.nasm }}
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-python
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-nodejs
            mingw-w64-${{ matrix.os.msystem == 'CLANG64' && 'clang-x86_64' || 'clang-aarch64' }}-gcc

      - uses: actions/checkout@v6
        with:
          submodules: true

      - uses: actions/setup-node@v6
        with:
          node-version: "24"

      - name: Apply PodFirst patches
        shell: bash
        run: |
          echo "Applying PodFirst patches for input device support..."
          cd externals/jellyfin-ffmpeg
          git apply --ignore-whitespace --ignore-space-change ../../patches/enable-indevs.patch || {
            echo "Standard apply failed, trying with --3way..."
            git apply --3way ../../patches/enable-indevs.patch
          }
          echo "âœ“ Patch applied successfully"
          grep -A5 "PodFirst:" builder/variants/defaults-gpl.sh || true

      - name: Read FFmpeg version
        id: ffmpeg-version
        shell: bash
        run: |
          FFMPEG_VERSION=$(cat externals/jellyfin-ffmpeg/FFMPEG_VERSION)
          echo "version=$FFMPEG_VERSION" >> $GITHUB_OUTPUT
          echo "FFmpeg version: $FFMPEG_VERSION"

      - name: Get Jellyfin FFmpeg commit hash
        id: ffmpeg-hash
        shell: bash
        run: |
          if [ -n "${{ env.JELLYFIN_FFMPEG_HASH }}" ]; then
            echo "hash=${{ env.JELLYFIN_FFMPEG_HASH }}" >> $GITHUB_OUTPUT
          else
            echo "hash=$(git -C externals/jellyfin-ffmpeg rev-parse HEAD)" >> $GITHUB_OUTPUT
          fi

      - name: Prepare directories
        run: |
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/lib/pkgconfig
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/include
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/bin

      - name: Restore FFmpeg cache
        id: cache-ffmpeg
        uses: actions/cache@v5
        with:
          path: |
            C:\ffmpeg-cache-${{ matrix.os.arch }}
            externals/jellyfin-ffmpeg/config*.h
          key: ffmpeg-windows-${{ matrix.os.arch }}-${{ env.CACHE_VERSION_WINDOWS }}-${{ steps.ffmpeg-hash.outputs.hash }}
          restore-keys: |
            ffmpeg-windows-${{ matrix.os.arch }}-${{ env.CACHE_VERSION_WINDOWS }}-${{ steps.ffmpeg-hash.outputs.hash }}
            ffmpeg-windows-${{ matrix.os.arch }}-${{ env.CACHE_VERSION_WINDOWS }}-

      - name: Copy cache to MSYS2 location
        if: steps.cache-ffmpeg.outputs.cache-hit == 'true'
        shell: msys2 {0}
        run: |
          CACHE_DIR="C:/ffmpeg-cache-${{ matrix.os.arch }}"
          MSYS_PREFIX="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild"

          if [ -d "${CACHE_DIR}" ]; then
            echo "Restoring FFmpeg cache from ${CACHE_DIR} to ${MSYS_PREFIX}"
            rm -rf "${MSYS_PREFIX}" 2>/dev/null || true
            mkdir -p "${MSYS_PREFIX}"
            cp -r "${CACHE_DIR}"/* "${MSYS_PREFIX}/"
            echo "Cache restored successfully"
          else
            echo "Cache directory ${CACHE_DIR} not found!"
            exit 1
          fi

      - name: Build FFmpeg
        id: build-ffmpeg
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        shell: msys2 {0}
        run: |
          # Clear out MSYS2 ffbuild to avoid conflicts
          rm -rf /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/lib/pkgconfig
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/include
          mkdir -p /${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild/bin

          cd externals/jellyfin-ffmpeg/msys2

          # Run Jellyfin build script
          if [ "${{ matrix.os.arch }}" = "arm64" ]; then
            ./buildarm64.sh
          else
            ./build.sh
          fi

          PREFIX="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild"

          # Install FFmpeg libraries
          cd ..
          make install

          # Copy FFmpeg libraries to main lib directory
          if [ -d "${PREFIX}/jellyfin-ffmpeg/lib" ]; then
            cp ${PREFIX}/jellyfin-ffmpeg/lib/*.a ${PREFIX}/lib/ 2>/dev/null || true
            cp -r ${PREFIX}/jellyfin-ffmpeg/include/* ${PREFIX}/include/ 2>/dev/null || true

            if [ -d "${PREFIX}/jellyfin-ffmpeg/lib/pkgconfig" ]; then
              mkdir -p ${PREFIX}/lib/pkgconfig
              cp ${PREFIX}/jellyfin-ffmpeg/lib/pkgconfig/*.pc ${PREFIX}/lib/pkgconfig/ 2>/dev/null || true
            fi
          fi

          echo "Verifying config files from FFmpeg build..."
          if [ ! -f config.h ]; then
            echo "Error: config.h not found in FFmpeg build directory!"
            exit 1
          fi

          if [ ! -f config_components.h ]; then
            echo "Error: config_components.h not found in FFmpeg build directory!"
            exit 1
          fi

          # List all config files for debugging
          ls -la config*.h || true
          echo "âœ“ Config files verified in externals/jellyfin-ffmpeg/"

      - name: Copy FFmpeg build to cache-friendly location
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        shell: msys2 {0}
        run: |
          MSYS_PREFIX="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/ffbuild"
          CACHE_DIR="C:/ffmpeg-cache-${{ matrix.os.arch }}"

          if [ -d "${MSYS_PREFIX}" ]; then
            echo "Copying FFmpeg build to cache location"
            rm -rf "${CACHE_DIR}" 2>/dev/null || true
            mkdir -p "${CACHE_DIR}"
            cp -r "${MSYS_PREFIX}"/* "${CACHE_DIR}/"
            echo "FFmpeg build cached successfully"
          else
            echo "FFmpeg build directory does not exist!"
            exit 1
          fi
      - name: Save FFmpeg cache
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        uses: actions/cache/save@v5
        with:
          path: |
            C:\ffmpeg-cache-${{ matrix.os.arch }}
            externals/jellyfin-ffmpeg/config*.h
          key: ffmpeg-windows-${{ matrix.os.arch }}-${{ env.CACHE_VERSION_WINDOWS }}-${{ steps.ffmpeg-hash.outputs.hash }}

      - name: Upload FFmpeg cache as artifact
        if: inputs.upload_caches == true
        uses: actions/upload-artifact@v5
        with:
          name: ffmpeg-cache-windows-${{ matrix.os.arch }}
          path: C:\ffmpeg-cache-${{ matrix.os.arch }}
          retention-days: 7

      - name: Package FFmpeg binary
        shell: msys2 {0}
        run: |
          if [ "${{ matrix.os.msystem }}" = "CLANG64" ]; then
            FFMPEG_BIN="/clang64/ffbuild/jellyfin-ffmpeg/bin/ffmpeg.exe"
          else
            FFMPEG_BIN="/clangarm64/ffbuild/jellyfin-ffmpeg/bin/ffmpeg.exe"
          fi

          if [ -f "$FFMPEG_BIN" ]; then
            mkdir -p ffmpeg-binary-win-${{ matrix.os.arch }}-jellyfin
            cp "$FFMPEG_BIN" ffmpeg-binary-win-${{ matrix.os.arch }}-jellyfin/ffmpeg.exe
            llvm-strip ffmpeg-binary-win-${{ matrix.os.arch }}-jellyfin/ffmpeg.exe
            echo "Packaged FFmpeg binary for win-${{ matrix.os.arch }}-jellyfin"
          else
            echo "Warning: FFmpeg binary not found at $FFMPEG_BIN"
          fi

      - name: Install Node dependencies
        run: npm install --ignore-scripts

      - name: Setup custom node-gyp
        shell: msys2 {0}
        run: |
          # Install and configure custom node-gyp from submodule
          pushd externals/node-gyp
          npm install
          npm link
          popd

          # Verify node-gyp is available
          which node-gyp
          node-gyp --version

      - name: Build Native Addon
        shell: msys2 {0}
        run: |
          cp binding-jellyfin.gyp binding.gyp

          if [ "${{ matrix.os.msystem }}" = "CLANG64" ]; then
            PREFIX="/clang64/ffbuild"
          else
            PREFIX="/clangarm64/ffbuild"
          fi

          # Set environment for MSYS2/Clang build
          export CC="clang"
          export CXX="clang++"
          export AR="llvm-ar"

          # Set pkg-config path
          export PKG_CONFIG_PATH="${PREFIX}/lib/pkgconfig:${PKG_CONFIG_PATH}"

          # Set include and lib paths
          export CFLAGS="-I${PREFIX}/include"
          export CXXFLAGS="-I${PREFIX}/include"
          export LDFLAGS="-L${PREFIX}/lib"

          # Use our custom node-gyp directly for better control
          NODE_GYP_PATH="$(pwd)/externals/node-gyp/bin/node-gyp.js"
          NODE_GYP_WIN_PATH="$(cygpath -w $NODE_GYP_PATH)"

          # Use --nodedir to point to MSYS2's Node.js installation
          NODE_PATH="/$(echo ${{ matrix.os.msystem }} | tr '[:upper:]' '[:lower:]')"
          NODE_WIN_PATH="$(cygpath -w $NODE_PATH)"

          # In MSYS2, make is usually called mingw32-make
          # Use --make to point to the correct make binary
          MAKE_PATH="/${{ matrix.os.msystem == 'CLANG64' && 'clang64' || 'clangarm64' }}/bin/mingw32-make.exe"
          MAKE_WIN_PATH="$(cygpath -w $MAKE_PATH)"

          node "${NODE_GYP_WIN_PATH}" rebuild \
            --verbose \
            --arch=${{ matrix.os.arch }} \
            --nodedir="${NODE_WIN_PATH}" \
            --make="${MAKE_WIN_PATH}" \
            --release

          # Create prebuilds directory structure
          PREBUILD_DIR="prebuilds/win32-${{ matrix.os.arch }}-mingw"
          mkdir -p "$PREBUILD_DIR"

          # Find the built .node file and copy it with consistent naming
          NODE_FILE=$(find build/Release -name "*.node" -type f | head -1)
          if [ -n "$NODE_FILE" ]; then
            cp "$NODE_FILE" "$PREBUILD_DIR/node-av.node"
            echo "Copied $(basename $NODE_FILE) -> node-av.node"

            # Strip the binary
            llvm-strip "$PREBUILD_DIR/node-av.node"

            # Copy binary for tests
            mkdir -p binary
            cp "$PREBUILD_DIR/node-av.node" binary/node-av.node
            echo "Copied binary for tests"

            # Copy FFmpeg binary to binary folder
            if [ -f "ffmpeg-binary-win-${{ matrix.os.arch }}-jellyfin/ffmpeg.exe" ]; then
              cp "ffmpeg-binary-win-${{ matrix.os.arch }}-jellyfin/ffmpeg.exe" binary/ffmpeg.exe
              echo "Copied FFmpeg binary for tests"
            fi
          else
            echo "Error: No .node file found in build/Release"
            exit 1
          fi

      - name: Check DLL dependencies
        shell: msys2 {0}
        run: |
          echo "=== Checking node-av.node dependencies ==="
          if [ -f "build/Release/node-av.node" ]; then
            objdump -p "build/Release/node-av.node" | grep "DLL Name:"
          fi

          echo ""
          echo "=== Checking FFmpeg binary dependencies ==="
          if [ -f "binary/ffmpeg.exe" ]; then
            objdump -p "binary/ffmpeg.exe" | grep "DLL Name:"
          fi

      - name: Run Tests
        env:
          AV_FROM_SOURCE: 1
        run: npm run test:all

      - name: Upload Prebuild
        uses: actions/upload-artifact@v5
        with:
          name: prebuild-windows-mingw-${{ matrix.os.arch }}
          path: prebuilds/

      - name: Upload FFmpeg binary
        uses: actions/upload-artifact@v5
        with:
          name: ffmpeg-v${{ steps.ffmpeg-version.outputs.version }}-win-${{ matrix.os.arch }}-jellyfin.zip
          path: ffmpeg-binary-win-${{ matrix.os.arch }}-jellyfin/

  build_windows_msvc:
    name: "Windows MSVC ${{ matrix.os.arch }}"
    runs-on: ${{ matrix.os.runner }}
    strategy:
      fail-fast: false
      matrix:
        os:
          - arch: x64
            runner: windows-2022
          - arch: arm64
            runner: windows-11-arm
    env:
      SDK_VER: 10.0.22621.0
      FFMPEG_MSVC_PREBUILT_URL: "https://api.github.com/repos/seydx/ffmpeg-msvc-prebuilt/releases/latest"
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: true

      - uses: actions/setup-node@v6
        with:
          node-version: "24"

      - name: Read FFmpeg version
        id: ffmpeg-version
        shell: bash
        run: |
          FFMPEG_VERSION=$(cat externals/jellyfin-ffmpeg/FFMPEG_VERSION)
          echo "version=$FFMPEG_VERSION" >> $GITHUB_OUTPUT
          echo "FFmpeg version: $FFMPEG_VERSION"

      - name: Prepare directories
        shell: bash
        run: |
          mkdir -p ffmpeg-msvc

      - name: Download FFmpeg MSVC Prebuilt
        shell: bash
        run: |
          # Determine architecture suffix
          if [ "${{ matrix.os.arch }}" = "x64" ]; then
            ARCH_SUFFIX="amd64"
          else
            ARCH_SUFFIX="arm64"
          fi

          # Get latest release info
          RELEASE_URL="${{ env.FFMPEG_MSVC_PREBUILT_URL }}"

          # Find the correct asset URL
          ASSET_URL=$(curl -s "$RELEASE_URL" | \
            grep "browser_download_url.*ffmpeg.*gpl-${ARCH_SUFFIX}-static.zip" | \
            cut -d '"' -f 4)

          if [ -z "$ASSET_URL" ]; then
            echo "Error: Could not find FFmpeg MSVC prebuilt asset"
            exit 1
          fi

          echo "Downloading FFmpeg MSVC prebuilt: $ASSET_URL"

          # Download and extract to project root
          curl -L "$ASSET_URL" -o ffmpeg-msvc-prebuilt.zip

          # Extract ZIP contents directly into ffmpeg-msvc directory
          unzip -q ffmpeg-msvc-prebuilt.zip -d ffmpeg-msvc

          echo "FFmpeg MSVC prebuilt extracted to ffmpeg-msvc/"
          ls -la ffmpeg-msvc/

      - name: Upload FFmpeg cache as artifact
        if: inputs.upload_caches == true
        uses: actions/upload-artifact@v5
        with:
          name: ffmpeg-cache-windows-msvc-${{ matrix.os.arch }}
          path: ffmpeg-msvc/
          retention-days: 7

      - name: Install Node dependencies
        run: npm install --ignore-scripts

      - name: Build Native Addon
        shell: powershell
        run: |
          # Use the MSVC-compatible binding.gyp
          Copy-Item binding.gyp binding.gyp.bak
          Copy-Item binding-msvc.gyp binding.gyp

          # Build N-API binary directly with node-gyp
          npx node-gyp configure --arch=${{ matrix.os.arch }} --verbose --release
          npx node-gyp build --arch=${{ matrix.os.arch }} --verbose --release

          # Create prebuilds directory structure
          New-Item -ItemType Directory -Path "binary" -Force
          New-Item -ItemType Directory -Path "prebuilds\win32-${{ matrix.os.arch }}-msvc" -Force

          # Copy the built .node file
          Copy-Item "build\Release\*.node" "binary\node-av.node"
          Copy-Item "build\Release\*.node" "prebuilds\win32-${{ matrix.os.arch }}-msvc\node-av.node"

          Write-Host "Build completed successfully"

      - name: Check DLL dependencies
        shell: powershell
        run: |
          Write-Host "=== Checking node-av.node dependencies ==="
          $dumpbin = Get-ChildItem "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\*\bin\Host*\${{ matrix.os.arch }}\dumpbin.exe" | Select-Object -First 1
          if ($dumpbin) {
            & $dumpbin /DEPENDENTS "build\Release\node-av.node"
          } else {
            Write-Host "dumpbin not found, trying alternative path"
            & "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.44.35207\bin\Hostx64\${{ matrix.os.arch }}\dumpbin.exe" /DEPENDENTS "build\Release\node-av.node"
          }

          Write-Host "`n=== Checking FFmpeg binary dependencies ==="
          if (Test-Path "ffmpeg-msvc\bin\ffmpeg.exe") {
            if ($dumpbin) {
              & $dumpbin /DEPENDENTS "ffmpeg-msvc\bin\ffmpeg.exe"
            } else {
              & "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.44.35207\bin\Hostx64\${{ matrix.os.arch }}\dumpbin.exe" /DEPENDENTS "ffmpeg-msvc\bin\ffmpeg.exe"
            }
          }

      - name: Package FFmpeg binary
        shell: powershell
        run: |
          $ffmpegBin = "ffmpeg-msvc\bin\ffmpeg.exe"
          if (Test-Path $ffmpegBin) {
            New-Item -ItemType Directory -Path "ffmpeg-binary-win-${{ matrix.os.arch }}" -Force
            Copy-Item $ffmpegBin "ffmpeg-binary-win-${{ matrix.os.arch }}\ffmpeg.exe"

            # Copy FFmpeg binary to binary folder for tests
            Copy-Item $ffmpegBin "binary\ffmpeg.exe"
            Write-Host "Copied FFmpeg binary for tests"

            Write-Host "Packaged FFmpeg binary for win-${{ matrix.os.arch }}"
          } else {
            Write-Host "Warning: FFmpeg binary not found at $ffmpegBin"
          }

      - name: Run Tests
        env:
          AV_FROM_SOURCE: 1
        run: npm run test:all

      - name: Upload prebuilds
        uses: actions/upload-artifact@v5
        with:
          name: prebuild-win32-msvc-${{ matrix.os.arch }}
          path: prebuilds/

      - name: Upload FFmpeg binary
        uses: actions/upload-artifact@v5
        with:
          name: ffmpeg-v${{ steps.ffmpeg-version.outputs.version }}-win-${{ matrix.os.arch }}.zip
          path: ffmpeg-binary-win-${{ matrix.os.arch }}/

  build_linux:
    name: "Linux ${{ matrix.arch }}"
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - arch: x64
            target: amd64
            runner: ubuntu-latest
          - arch: arm64
            target: arm64
            runner: ubuntu-24.04-arm
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: true

      - uses: actions/setup-node@v6
        with:
          node-version: "24"

      - name: Apply PodFirst patches
        run: |
          echo "Applying PodFirst patches for input device support..."
          cd externals/jellyfin-ffmpeg
          git apply --ignore-whitespace --ignore-space-change ../../patches/enable-indevs.patch || {
            echo "Standard apply failed, trying with --3way..."
            git apply --3way ../../patches/enable-indevs.patch
          }
          echo "âœ“ Patch applied successfully"
          grep -A5 "PodFirst:" builder/variants/defaults-gpl.sh || true

      - name: Read FFmpeg version
        id: ffmpeg-version
        run: |
          FFMPEG_VERSION=$(cat externals/jellyfin-ffmpeg/FFMPEG_VERSION)
          echo "version=$FFMPEG_VERSION" >> $GITHUB_OUTPUT
          echo "FFmpeg version: $FFMPEG_VERSION"

      - name: Get Jellyfin FFmpeg commit hash
        id: ffmpeg-hash
        run: |
          if [ -n "${{ env.JELLYFIN_FFMPEG_HASH }}" ]; then
            echo "hash=${{ env.JELLYFIN_FFMPEG_HASH }}" >> $GITHUB_OUTPUT
          else
            echo "hash=$(git -C externals/jellyfin-ffmpeg rev-parse HEAD)" >> $GITHUB_OUTPUT
          fi

      - name: Prepare directories
        run: |
          sudo mkdir -p /opt/ffbuild/prefix
          sudo chown -R $USER:$USER /opt/ffbuild
          sudo chmod -R 755 /opt/ffbuild

      - name: Restore FFmpeg cache
        id: cache-ffmpeg
        uses: actions/cache@v5
        with:
          path: |
            /opt/ffbuild/prefix
            externals/jellyfin-ffmpeg/config*.h
          key: ffmpeg-linux-${{ matrix.arch }}-${{ env.CACHE_VERSION_LINUX }}-${{ steps.ffmpeg-hash.outputs.hash }}
          restore-keys: |
            ffmpeg-linux-${{ matrix.arch }}-${{ env.CACHE_VERSION_LINUX }}-${{ steps.ffmpeg-hash.outputs.hash }}
            ffmpeg-linux-${{ matrix.arch }}-${{ env.CACHE_VERSION_LINUX }}-

      - name: Build FFmpeg
        id: build-ffmpeg
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          # Clear out /opt/ffbuild to avoid conflicts
          sudo rm -rf /opt/ffbuild
          sudo mkdir -p /opt/ffbuild/prefix
          sudo chown -R $USER:$USER /opt/ffbuild
          sudo chmod -R 755 /opt/ffbuild

          cd externals/jellyfin-ffmpeg/builder

          # Determine target
          if [ "${{ matrix.target }}" = "amd64" ]; then
            TARGET="linux64"
          else
            TARGET="linuxarm64"
          fi

          # Determine Docker image to use
          IMAGE="ghcr.io/seydx/jellyfin-ffmpeg/${TARGET}-gpl:latest"

          # Try to pull image from registry first
          if docker pull "${IMAGE}" 2>/dev/null; then
            echo "âœ“ Using Docker image from registry: ${IMAGE}"
          else
            # If not available, build it locally
            echo "Docker image not in registry, building locally..."
            # Override GITHUB_REPOSITORY for makeimage.sh
            GITHUB_REPOSITORY="seydx/jellyfin-ffmpeg" ./makeimage.sh "${TARGET}" gpl
          fi

          # Override GITHUB_REPOSITORY to use seydx/jellyfin-ffmpeg images
          export GITHUB_REPOSITORY="seydx/jellyfin-ffmpeg"

          # Run Jellyfin build script
          ./build.sh "${TARGET}" gpl

          # Now extract the prefix directory which contains all headers and static libraries
          if [ -d ffbuild/prefix ]; then
            sudo mkdir -p /opt/ffbuild/prefix
            sudo cp -r ffbuild/prefix/* /opt/ffbuild/prefix/

            # Copy all config*.h files from FFmpeg build directory (required for internal headers)
            echo "Copying config files from FFmpeg build directory..."
            for config_file in ffbuild/ffmpeg/config*.h; do
              if [ -f "$config_file" ]; then
                filename=$(basename "$config_file")
                sudo cp "$config_file" "../$filename"
                echo "âœ“ Copied $filename"
              fi
            done

            if [ ! -f ../config.h ]; then
              echo "Error: config.h not found in FFmpeg build directory!"
              exit 1
            fi

            if [ ! -f ../config_components.h ]; then
              echo "Error: config_components.h not found in FFmpeg build directory!"
              exit 1
            fi

            # Also check if codec libraries are in /opt/ffbuild inside container
            # We might need to extract them from our Docker image
            CONTAINER_ID=$(docker create "ghcr.io/seydx/jellyfin-ffmpeg/${TARGET}-gpl:latest")
            # Try to copy codec libraries if they exist
            docker cp "${CONTAINER_ID}:/opt/ffbuild/lib" /tmp/codec-libs 2>/dev/null && {
              sudo cp -n /tmp/codec-libs/*.a /opt/ffbuild/prefix/lib/ 2>/dev/null || true
              rm -rf /tmp/codec-libs
            }
            docker cp "${CONTAINER_ID}:/opt/ffbuild/include" /tmp/codec-includes 2>/dev/null && {
              sudo cp -rn /tmp/codec-includes/* /opt/ffbuild/prefix/include/ 2>/dev/null || true
              rm -rf /tmp/codec-includes
            }
            docker rm "${CONTAINER_ID}"

            # Clean up the preserved ffbuild directory now
            rm -rf ffbuild

            sudo chown -R $USER:$USER /opt/ffbuild
          else
            echo "Error: ffbuild/prefix not found!"
            exit 1
          fi

          cd ../..

      - name: Save FFmpeg cache
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        uses: actions/cache/save@v5
        with:
          path: |
            /opt/ffbuild/prefix
            externals/jellyfin-ffmpeg/config*.h
          key: ffmpeg-linux-${{ matrix.arch }}-${{ env.CACHE_VERSION_LINUX }}-${{ steps.ffmpeg-hash.outputs.hash }}

      - name: Upload FFmpeg cache as artifact
        if: inputs.upload_caches == true
        uses: actions/upload-artifact@v5
        with:
          name: ffmpeg-cache-linux-${{ matrix.arch }}
          path: /opt/ffbuild/prefix
          retention-days: 7

      - name: Package FFmpeg binary
        run: |
          FFMPEG_BIN="/opt/ffbuild/prefix/bin/ffmpeg"
          if [ -f "$FFMPEG_BIN" ]; then
            mkdir -p ffmpeg-binary-linux-${{ matrix.arch }}-jellyfin
            cp "$FFMPEG_BIN" ffmpeg-binary-linux-${{ matrix.arch }}-jellyfin/ffmpeg
            strip ffmpeg-binary-linux-${{ matrix.arch }}-jellyfin/ffmpeg
            echo "Packaged FFmpeg binary for linux-${{ matrix.arch }}-jellyfin"
          else
            echo "Warning: FFmpeg binary not found at $FFMPEG_BIN"
          fi

      - name: Build Native Addon in Docker
        run: |
          cp binding-jellyfin.gyp binding.gyp

          # Determine target based on architecture
          if [ "${{ matrix.target }}" = "amd64" ]; then
            TARGET="linux64"
          else
            TARGET="linuxarm64"
          fi

          # Determine Docker image to use
          IMAGE="ghcr.io/seydx/jellyfin-ffmpeg/${TARGET}-gpl:latest"

          # Pull image if not already cached locally
          if ! docker image inspect "${IMAGE}" > /dev/null 2>&1; then
            echo "Pulling Docker image: ${IMAGE}"
            docker pull "${IMAGE}"
          else
            echo "Using locally cached Docker image: ${IMAGE}"
          fi

          # Run the build inside the Docker container
          docker run --rm \
            -v "$(pwd)":/workspace \
            -v /opt/ffbuild:/opt/ffbuild \
            -w /workspace \
            -e PKG_CONFIG_PATH="/opt/ffbuild/prefix/lib/pkgconfig" \
            "${IMAGE}" \
            bash -c "
              set -e

              # Install Node.js in the container
              curl -fsSL https://deb.nodesource.com/setup_24.x | bash -
              apt-get install -y nodejs

              # Verify Node.js installation
              node --version
              npm --version

              # Install dependencies
              npm install --ignore-scripts

              # Build with GCC from crosstool-ng (native GCC 15.2.0)
              npx prebuildify \
                --napi \
                --strip \
                --arch=${{ matrix.arch }} \
                --tag-libc

              # Fix ownership (Docker runs as root)
              chown -R 1001:127 prebuilds node_modules build 2>/dev/null || true
            "

          # Rename the built file to node-av.node for consistency
          BUILT_FILE=$(find prebuilds -name "*.node" -type f | head -1)
          if [ -n "$BUILT_FILE" ]; then
            DIR=$(dirname "$BUILT_FILE")
            mv "$BUILT_FILE" "$DIR/node-av.node"
            echo "Renamed $(basename $BUILT_FILE) -> node-av.node"

            # Copy binary for tests
            mkdir -p binary
            cp "$DIR/node-av.node" binary/node-av.node
            echo "Copied binary for tests"

            # Copy FFmpeg binary to binary folder
            if [ -f "ffmpeg-binary-linux-${{ matrix.arch }}-jellyfin/ffmpeg" ]; then
              cp "ffmpeg-binary-linux-${{ matrix.arch }}-jellyfin/ffmpeg" binary/ffmpeg
              echo "Copied FFmpeg binary for tests"
            fi
          else
            echo "Error: No .node file found in prebuilds directory"
            exit 1
          fi

      - name: Run Tests
        env:
          AV_FROM_SOURCE: 1
        run: npm run test:all

      - name: Upload Prebuild
        uses: actions/upload-artifact@v5
        with:
          name: prebuild-linux-${{ matrix.arch }}
          path: prebuilds/

      - name: Upload FFmpeg binary
        uses: actions/upload-artifact@v5
        with:
          name: ffmpeg-v${{ steps.ffmpeg-version.outputs.version }}-linux-${{ matrix.arch }}-jellyfin.zip
          path: ffmpeg-binary-linux-${{ matrix.arch }}-jellyfin/

  build_macos:
    name: "macOS ${{ matrix.arch }}"
    runs-on: macos-latest
    strategy:
      fail-fast: false
      matrix:
        arch: [x64, arm64]
    steps:
      - uses: actions/checkout@v6
        with:
          submodules: true

      - uses: actions/setup-node@v6
        with:
          node-version: "24"

      - name: Set up Homebrew
        uses: Homebrew/actions/setup-homebrew@master

      - name: Apply PodFirst patches
        run: |
          echo "Applying PodFirst patches for input device support..."
          cd externals/jellyfin-ffmpeg
          git apply --ignore-whitespace --ignore-space-change ../../patches/enable-indevs.patch || {
            echo "Standard apply failed, trying with --3way..."
            git apply --3way ../../patches/enable-indevs.patch
          }
          echo "âœ“ Patch applied successfully"
          grep -A5 "PodFirst:" builder/variants/defaults-gpl.sh || true

      - name: Read FFmpeg version
        id: ffmpeg-version
        run: |
          FFMPEG_VERSION=$(cat externals/jellyfin-ffmpeg/FFMPEG_VERSION)
          echo "version=$FFMPEG_VERSION" >> $GITHUB_OUTPUT
          echo "FFmpeg version: $FFMPEG_VERSION"

      - name: Get Jellyfin FFmpeg commit hash
        id: ffmpeg-hash
        run: |
          if [ -n "${{ env.JELLYFIN_FFMPEG_HASH }}" ]; then
            echo "hash=${{ env.JELLYFIN_FFMPEG_HASH }}" >> $GITHUB_OUTPUT
          else
            echo "hash=$(git -C externals/jellyfin-ffmpeg rev-parse HEAD)" >> $GITHUB_OUTPUT
          fi

      - name: Prepare directories
        run: |
          sudo mkdir -p /opt/ffbuild/prefix
          sudo chown -R $USER:staff /opt/ffbuild
          sudo chmod -R 755 /opt/ffbuild

      - name: Restore FFmpeg cache
        id: cache-ffmpeg
        uses: actions/cache@v5
        with:
          path: |
            /opt/ffbuild/prefix
            externals/jellyfin-ffmpeg/config*.h
          key: ffmpeg-macos-${{ matrix.arch }}-${{ env.CACHE_VERSION_MACOS }}-${{ steps.ffmpeg-hash.outputs.hash }}
          restore-keys: |
            ffmpeg-macos-${{ matrix.arch }}-${{ env.CACHE_VERSION_MACOS }}-${{ steps.ffmpeg-hash.outputs.hash }}
            ffmpeg-macos-${{ matrix.arch }}-${{ env.CACHE_VERSION_MACOS }}-

      - name: Build FFmpeg
        id: build-ffmpeg
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true'
        run: |
          # Clear out /opt/ffbuild to avoid conflicts
          sudo rm -rf /opt/ffbuild
          sudo mkdir -p /opt/ffbuild/prefix
          sudo chown -R $USER:staff /opt/ffbuild
          sudo chmod -R 755 /opt/ffbuild

          cd externals/jellyfin-ffmpeg/builder

          # Map our arch names to Jellyfin's
          ARCH_NAME="${{ matrix.arch }}"
          if [ "$ARCH_NAME" = "x64" ]; then
            ARCH_NAME="x86_64"
          fi

          # Run Jellyfin build script
          ./buildmac.sh $ARCH_NAME

          # The build script uses /ffbuild/prefix but we need /opt/ffbuild/prefix
          # Also need to run make install to get FFmpeg libraries
          cd ..
          make install DESTDIR="" prefix="/opt/ffbuild/prefix"

          echo "Verifying config files from FFmpeg build..."
          if [ ! -f config.h ]; then
            echo "Error: config.h not found in FFmpeg build directory!"
            exit 1
          fi

          if [ ! -f config_components.h ]; then
            echo "Error: config_components.h not found in FFmpeg build directory!"
            exit 1
          fi

          # List all config files for debugging
          ls -la config*.h || true
          echo "âœ“ Config files verified in externals/jellyfin-ffmpeg/"

          # Fix permissions before caching
          sudo chown -R $USER:staff /opt/ffbuild

          cd ..

      - name: Save FFmpeg cache
        if: steps.cache-ffmpeg.outputs.cache-hit != 'true' && steps.build-ffmpeg.outcome == 'success'
        uses: actions/cache/save@v5
        with:
          path: |
            /opt/ffbuild/prefix
            externals/jellyfin-ffmpeg/config*.h
          key: ffmpeg-macos-${{ matrix.arch }}-${{ env.CACHE_VERSION_MACOS }}-${{ steps.ffmpeg-hash.outputs.hash }}

      - name: Upload FFmpeg cache as artifact
        if: inputs.upload_caches == true
        uses: actions/upload-artifact@v5
        with:
          name: ffmpeg-cache-macos-${{ matrix.arch }}
          path: /opt/ffbuild/prefix
          retention-days: 7

      - name: Package FFmpeg binary
        run: |
          FFMPEG_BIN="/opt/ffbuild/prefix/bin/ffmpeg"
          if [ -f "$FFMPEG_BIN" ]; then
            mkdir -p ffmpeg-binary-macos-${{ matrix.arch }}-jellyfin
            cp "$FFMPEG_BIN" ffmpeg-binary-macos-${{ matrix.arch }}-jellyfin/ffmpeg
            strip ffmpeg-binary-macos-${{ matrix.arch }}-jellyfin/ffmpeg
            echo "Packaged FFmpeg binary for macos-${{ matrix.arch }}-jellyfin"
          else
            echo "Warning: FFmpeg binary not found at $FFMPEG_BIN"
          fi

      - name: Install Node dependencies
        run: npm install --ignore-scripts

      - name: Build Native Addon
        run: |
          cp binding-jellyfin.gyp binding.gyp

          # For x64 builds on ARM64 runner, set up cross-compilation
          if [ "${{ matrix.arch }}" = "x64" ] && [ "$(uname -m)" = "arm64" ]; then
            echo "Setting up Node.js cross-compilation for x86_64"
            export CFLAGS="-arch x86_64"
            export CXXFLAGS="-arch x86_64"
            export LDFLAGS="-arch x86_64"
            export npm_config_arch=x64
            export npm_config_target_arch=x64
            export npm_config_disturl=https://nodejs.org/dist
            export npm_config_runtime=node
            export npm_config_build_from_source=true
          fi

          # Build N-API binary
          npx prebuildify \
            --napi \
            --strip \
            --arch=${{ matrix.arch }}

          # Rename the built file to node-av.node for consistency
          BUILT_FILE=$(find prebuilds -name "*.node" -type f | head -1)
          if [ -n "$BUILT_FILE" ]; then
            DIR=$(dirname "$BUILT_FILE")
            mv "$BUILT_FILE" "$DIR/node-av.node"
            echo "Renamed $(basename $BUILT_FILE) -> node-av.node"

            # Copy binary for tests
            mkdir -p binary
            cp "$DIR/node-av.node" binary/node-av.node
            echo "Copied binary for tests"

            # Copy FFmpeg binary to binary folder
            if [ -f "ffmpeg-binary-macos-${{ matrix.arch }}-jellyfin/ffmpeg" ]; then
              cp "ffmpeg-binary-macos-${{ matrix.arch }}-jellyfin/ffmpeg" binary/ffmpeg
              echo "Copied FFmpeg binary for tests"
            fi
          else
            echo "Error: No .node file found in prebuilds directory"
            exit 1
          fi

      - name: Run Tests
        if: matrix.arch == 'arm64'
        env:
          AV_FROM_SOURCE: 1
        run: npm run test:all

      - name: Upload Prebuild
        uses: actions/upload-artifact@v5
        with:
          name: prebuild-macos-${{ matrix.arch }}
          path: prebuilds/

      - name: Upload FFmpeg binary
        uses: actions/upload-artifact@v5
        with:
          name: ffmpeg-v${{ steps.ffmpeg-version.outputs.version }}-macos-${{ matrix.arch }}-jellyfin.zip
          path: ffmpeg-binary-macos-${{ matrix.arch }}-jellyfin/
